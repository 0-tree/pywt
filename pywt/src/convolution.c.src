/* Copyright (c) 2006-2012 Filip Wasilewski <http://en.ig.ma/> */
/* See COPYING for license details. */

#include "convolution.h"

/**begin repeat
 * #type = double, float#
 */

int @type@_downsampling_convolution_periodization(const @type@ * const restrict input, const index_t N,
                                                  const @type@ * const restrict filter, const index_t F,
                                                  @type@ * const restrict output, const index_t step)
{
    /*
    * Should it be an error to call this mode with signal lengths
    * not divisible by the step? Not really periodic if padded.
    *
    * If it is exactly divisible, can it be replaced by one loop?
    *   for (i=0; i < N; i += step){
    *     @type@ sum = 0;
    *     for (j=0; j < F; j++){
    *       sum += filter[j] * input[(i-j+N) % N];
    *     *(ptr_w++) = sum;
    *   }
    */

    index_t i = F/2, o = 0;
    const index_t padding = N % 2; // Should be N%step for larger steps?

    for (; i < F && i < N; i += step, ++o) {
        @type@ sum = 0;
        index_t j;
        for (j = 0; j <= i; ++j)
            sum += filter[j] * input[i-j];
        while (j < F){
            for (index_t k = 0; k < padding && j < F; ++k, ++j)
                sum += filter[j] * input[N-1];
            for (index_t k = 0; k < N && j < F; ++k, ++j)
                sum += filter[j] * input[N-1-k];
        }
        output[o] = sum;
    }

    /* F - N-1 : filter in input range.  Most time is spent in this loop */
    for(; i < N; i+=step, ++o){    /* input elements, */
        @type@ sum = 0;
        for(index_t j = 0; j < F; ++j)
            sum += input[i-j]*filter[j];
        output[o] = sum;
    }

    for (; i < F && i < N + F/2; i += step, ++o) {
        @type@ sum = 0;
        index_t j = 0;

        while (i-j >= N){
            for (index_t k = 0; k < padding && i-j >= N; ++k, ++j)
                sum += filter[i-N-j] * input[N-1];
            for (index_t k = 0; k < N && i-j >= N; ++k, ++j)
                sum += filter[i-N-j] * input[k];
        }
        for (; j <= i; ++j)
            sum += filter[j] * input[i-j];
        while (j < F){
            for (index_t k = 0; k < padding && j < F; ++k, ++j)
                sum += filter[j] * input[N-1];
            for (index_t k = 0; k < N && j < F; ++k, ++j)
                sum += filter[j] * input[N-1-k];
        }
        output[o] = sum;
    }

    for(; i < N + F/2; i += step, ++o){   /* input elements */
        @type@ sum = 0;
        index_t j = 0;
        while (i-j >= N){
            for (index_t k = 0; k < padding && i-j >= N; ++k, ++j)
                sum += filter[i-N-j] * input[N-1];
            for (index_t k = 0; k < N && i-j >= N; ++k, ++j)
                sum += filter[i-N-j] * input[k];
        }
        for (; j < F; ++j)
            sum += filter[j] * input[i-j];
        output[o] = sum;
    }
    return 0;
}


int @type@_downsampling_convolution(const @type@ * const restrict input, const index_t N,
                                    const @type@ * const restrict filter, const index_t F,
                                    @type@ * const restrict output,
                                    const index_t step, MODE mode)
{
    /*
     * This convolution performs efficient downsampling by computing every
     * step'th element of normal convolution (currently tested only for step=1
     * and step=2).
     *
     * It also implements several different strategies of dealing with border
     * distortion problem (the problem of computing convolution for not
     * existing elements of signal). To handle this the signal has to be
     * "extended" on both sides by computing the missing values.
     *
     * General schema is as follows:
     * 1. Handle extended on the left, convolve filter with samples computed for
     *    time < 0
     * 2. Do the normal decimated convolution of filter with signal samples
     * 3. Handle case where filter extends beyond signal to both the left and
     *    right (only applies if F > N)
     * 4. Handle extended on the right, convolve filter with samples computed
     *    for time > n-1
     */

    index_t i = step - 1, o = 0;

    if(mode == MODE_PERIODIZATION)
        return @type@_downsampling_convolution_periodization(input, N, filter, F, output, step);

    if (mode == MODE_SMOOTH && N < 2)
        mode = MODE_CONSTANT_EDGE;

    /* Other signal extension modes */
    /* 0 - F-1 : sliding in filter */
    for(; i < F && i < N; i+=step, ++o){
        @type@ sum = 0;
        index_t j;
        for(j = 0; j <= i; ++j)
            sum += filter[j]*input[i-j];

        switch(mode) {
        case MODE_SYMMETRIC:
            while (j < F){
                for(index_t k = 0; k < N && j < F; ++j, ++k)
                    sum += filter[j]*input[k];
                for(index_t k = 0; k < N && j < F; ++k, ++j)
                    sum += filter[j] * input[N-1-k];
            }
            break;
        case MODE_CONSTANT_EDGE:
            for(; j < F; ++j)
                sum += filter[j]*input[0];
            break;
        case MODE_SMOOTH:
            for(index_t k = 1; j < F; ++j, ++k)
                sum += filter[j]*(input[0] + k * (input[0] - input[1]));
            break;
        case MODE_PERIODIC:
            while (j < F)
                for(index_t k = 0; k < N && j < F; ++k, ++j)
                    sum += filter[j]*input[N-1-k];
            break;
        case MODE_ZEROPAD:
        default:
            break;
        }
        output[o] = sum;
    }

    /*
     * F - N-1 : filter in input range - simple convolution
     * Most time is spent in this loop.
     */
    for(; i < N; i+=step, ++o){  /* input elements, */
        @type@ sum = 0;

        for(index_t j = 0; j < F; ++j)
            sum += input[i-j]*filter[j];
        output[o] = sum;
    }

    for(; i < F; i+=step, ++o){
        @type@ sum = 0;
        index_t j = 0;
        switch(mode) {
        case MODE_SYMMETRIC:
            /* TODO: add offset to j? Inherited, not sure what this means */
            // Process elements beyond end in reverse (i.e. away from data)
            while (i - j >= N){
                for(index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[N-1-k];
                for(index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[k];
            }
            break;
        case MODE_CONSTANT_EDGE:
            for(; i-j >= N; ++j)
                sum += filter[j]*input[N-1];
            break;
        case MODE_SMOOTH:
            for(index_t k = i - N + 1; i-j >= N; ++j, --k)
                sum += filter[j]*(input[N-1] + k * (input[N-1] - input[N-2]));
            break;
        case MODE_PERIODIC:
            while (i-j >= N)
                for (index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[k];
            break;
        case MODE_ZEROPAD:
        default:
            j = i - N + 1;
            break;
        }
        for(; j <= i; ++j)
            sum += filter[j]*input[i-j];
        switch(mode) {
        case MODE_SYMMETRIC:
            while (j < F){
                for(index_t k = 0; k < N && j < F; ++j, ++k)
                    sum += filter[j]*input[k];
                for(index_t k = 0; k < N && j < F; ++k, ++j)
                    sum += filter[j] * input[N-1-k];
            }
            break;
        case MODE_CONSTANT_EDGE:
            for(; j < F; ++j)
                sum += filter[j]*input[0];
            break;
        case MODE_SMOOTH:
            for(index_t k = 1; j < F; ++j, ++k)
                sum += filter[j]*(input[0] + k * (input[0] - input[1]));
            break;
        case MODE_PERIODIC:
            while (j < F)
                for(index_t k = 0; k < N && j < F; ++k, ++j)
                    sum += filter[j]*input[N-1-k];
            break;
        case MODE_ZEROPAD:
        default:
            break;
        }
        output[o] = sum;
    }

    /* N - N+F-1 : sliding out filter */
    for(; i < N+F-1; i += step, ++o){
        @type@ sum = 0;
        index_t j = 0;
        switch(mode) {
        case MODE_SYMMETRIC:
            /* TODO: add offset to j? Inherited, not sure what this means */
            // Process elements beyond end in reverse (i.e. away from data)
            while (i - j >= N){
                for(index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[N-1-k];
                for(index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[k];
            }
            break;
        case MODE_CONSTANT_EDGE:
            for(; i-j >= N; ++j)
                sum += filter[j]*input[N-1];
            break;
        case MODE_SMOOTH:
            for(index_t k = i - N + 1; i-j >= N; ++j, --k)
                sum += filter[j]*(input[N-1] + k * (input[N-1] - input[N-2]));
            break;
        case MODE_PERIODIC:
            while (i-j >= N)
                for (index_t k = 0; k < N && i-j >= N; ++j, ++k)
                    sum += filter[i-N-j]*input[k];
            break;
        case MODE_ZEROPAD:
        default:
            j = i - N + 1;
            break;
        }
        for(; j < F; ++j)
            sum += filter[j]*input[i-j];
        output[o] = sum;
    }
    return 0;
}

/*
 * Requires zero-filled output buffer output is larger than input
 * performs "normal" convolution of "upsampled" input coeffs array with filter
 */

int @type@_upsampling_convolution_full(const @type@ * const restrict input, const index_t N,
                                       const @type@ * const restrict filter, const index_t F,
                                       @type@ * const restrict output, const index_t O)
{
    if(F<2)
        return -1;

    index_t i = 0, o = 0;

    // Sliding filter in
    for(; i < N && i < F/2; ++i, o += 2)
        for(index_t j = 0; j <= i; ++j){
            output[o] += filter[j*2] * input[i-j];
            output[o+1] += filter[j*2+1] * input[i-j];
        }

    // Equivalent to upsampling_convolution_valid_sf
    for(; i < N; ++i, o += 2)
        for(index_t j = 0; j < F/2; ++j){
            output[o] += filter[j*2] * input[i-j];
            output[o+1] += filter[j*2+1] * input[i-j];
        }

    // Sliding filter out
    for(; i < N+F/2; ++i, o += 2)
        for(index_t j = i-(N-1); j < F/2; ++j){
            output[o] += filter[j*2] * input[i-j];
            output[o+1] += filter[j*2+1] * input[i-j];
        }
    return 0;
}

/*
 * performs IDWT for PERIODIZATION mode only
 * (refactored from the upsampling_convolution_valid_sf function)
 *
 * The upsampling is performed by splitting filters to even and odd elements
 * and performing 2 convolutions
 *
 * The input data has to be periodically extended for this mode.
 */

int @type@_upsampling_convolution_valid_sf_periodization(const @type@* input, const index_t N,
                                                         const @type@* filter, const index_t F,
                                                         @type@* output, const index_t O)
{
    if(F%2) return -3; /* Filter must have even-length. */

    /*
     * Handle special situation when input coeff data is shorter than half of
     * the filter's length. The coeff array has to be extended periodically.
     * This can be only valid for PERIODIZATION_MODE
     */
    if(N < F/2) {
        index_t const start = F/4;
        index_t i = start;
        index_t const end = ((F/2)%2) ? N + F/4 : N + F/4 - 1;
        index_t o = ((F/2)%2) ? 0 : 1;

        if ((F/2)%2 == 0){
            // Shift everything one element right

            // i = N-1; even element goes to output[O-1], odd element goes to output[o]
            index_t j = 0;
            while(N+start-1-j >= N){
                for (index_t k = 0; k < N && N+start-1-j >= N; ++k, ++j){
                    output[2*N-1] += filter[2*(N+start-1-N-j)] * input[k];
                    output[0] += filter[2*(N+start-1-N-j)+1] * input[k];
                }
            }
            for (; j <= N+start-1 && j < F/2; ++j){
                output[2*N-1] += filter[2*j] * input[N+start-1-j];
                output[0] += filter[2*j+1] * input[N+start-1-j];
            }
            while (j < F / 2){
                for (index_t k = 0; k < N && j < F/2; ++k, ++j){
                    output[2*N-1] += filter[2*j] * input[N-1-k];
                    output[0] += filter[2*j+1] * input[N-1-k];
                }
            }
        }

        for (; i < N; ++i, o += 2){
            index_t j = 0;
            for(; j <= i; ++j){
                output[o] += filter[2*j] * input[i-j];
                output[o+1] += filter[2*j+1] * input[i-j];
            }
            while (j < F/2){
                for(index_t k = 0; k < N && j < F/2; ++k, ++j){
                    output[o] += filter[2*j] * input[N-1-k];
                    output[o+1] += filter[2*j+1] * input[N-1-k];
                }
            }
        }

        for (; i < end; ++i, o += 2){
            index_t j = 0;
            while(i-j >= N){
                for (index_t k = 0; k < N && i-j >= N; ++k, ++j){
                    output[o] += filter[2*(i-N-j)] * input[k];
                    output[o+1] += filter[2*(i-N-j)+1] * input[k];
                }
            }
            for (; j <= i && j < F/2; ++j){
                output[o] += filter[2*j] * input[i-j];
                output[o+1] += filter[2*j+1] * input[i-j];
            }
            while (j < F / 2){
                for (index_t k = 0; k < N && j < F/2; ++k, ++j){
                    output[o] += filter[2*j] * input[N-1-k];
                    output[o+1] += filter[2*j+1] * input[N-1-k];
                }
            }
        }

    } else {
        /* Otherwise (N >= F_2) */
        @type@ * ptr_out = output;
        @type@ * periodization_buf_front = NULL, * periodization_buf_rear = NULL;

        /*
         * ############################################################
         * This part is quite complicated and has some wild checking to
         * get results similar to those from Matlab(TM) Wavelet Toolbox
         */
        index_t k = F/2-1; // NOT const

        /* Check if extending is really needed */
        /* split filter len correct + extra samples*/
        const index_t N_p = k + (index_t) ceil(k/2.);

        /*
         * ok, if is then do:
         * 1. Allocate buffers for front and rear parts of extended input
         * 2. Copy periodically appropriate elements from input to the buffers
         * 3. Convolve front buffer, input and rear buffer with even and odd
         *    elements of the filter (this results in upsampling)
         * 4. Free memory
         */
        if(N_p > 0){
            /*
             * Allocate memory only for the front and rear extension parts, not
             * the whole input
             */
            periodization_buf_front = wtcalloc(N_p, sizeof(@type@));
            periodization_buf_rear = wtcalloc(N_p, sizeof(@type@));

            /* Memory checking */
            if(periodization_buf_front == NULL || periodization_buf_rear == NULL){
                if(periodization_buf_front == NULL) wtfree(periodization_buf_front);
                if(periodization_buf_rear == NULL) wtfree(periodization_buf_rear);
                return -1;
            }

            /* Fill buffers with appropriate elements */

            /* copy from beginning of input to end of buffer */
            memcpy(periodization_buf_front + N_p - k, input, k * sizeof(@type@));
            for(index_t i = 1; i <= (N_p - k); ++i)
                periodization_buf_front[(N_p - k) - i] = input[N - (i%N)];

            /* copy from end of input to beginning of buffer */
            memcpy(periodization_buf_rear, input + N - k, k * sizeof(@type@));
            for(index_t i = 0; i < (N_p - k); ++i)
                periodization_buf_rear[k + i] = input[i%N];

            /*
             * Convolve filters with the (front) periodization_buf and compute
             * the first part of output
             */

            if(k%2 == 1){
                @type@ sum_odd = 0;

                for(index_t j = 0; j < F/2; ++j)
                    sum_odd += filter[j*2+1] * periodization_buf_front[F/2-1-j];
                *(ptr_out++) += sum_odd;

                --k;
                if(k)
                    @type@_upsampling_convolution_valid_sf(periodization_buf_front + 1, N_p-1,
                                                           filter, F, ptr_out, O-1, MODE_ZEROPAD);

                ptr_out += k; /* k0 - 1, really move backward by 1 */

            } else if(k){
                @type@_upsampling_convolution_valid_sf(periodization_buf_front, N_p,
                                                        filter, F, ptr_out, O,
                                                        MODE_ZEROPAD);
                ptr_out += k;
            }
        }

        /*
         * Perform _valid_ convolution (only when all filter_even and
         * filter_odd elements are in range of input data).
         *
         * This part is simple, no extra hacks, just two convolutions in one
         * loop
         */

        for(index_t i = F/2 - 1; i < N; ++i){ /* sliding over signal from left to right */
            @type@ sum_even = 0;
            @type@ sum_odd = 0;

            for(index_t j = 0; j < F/2; ++j){
                sum_even += filter[j*2] * input[i-j];
                sum_odd += filter[j*2+1] * input[i-j];
            }

            *(ptr_out++) += sum_even;
            *(ptr_out++) += sum_odd;
        }

        if(N_p > 0){
            k = F/2-1;
            if(k%2 == 1){
                if(F/2 <= N_p - 1){ /* k > 1 ? */
                    @type@_upsampling_convolution_valid_sf(periodization_buf_rear, N_p-1,
                                                           filter, F, ptr_out, O-1,
                                                           MODE_ZEROPAD);
                }

                ptr_out += k; /* move forward anyway -> see lower */

                if((F/2)%2 == 0){ /* remaining one element */
                    @type@ sum_even = 0;
                    for(index_t j = 0; j < F/2; ++j){
                        sum_even += filter[j*2] * periodization_buf_rear[N_p-1-j];
                    }
                    *(--ptr_out) += sum_even; /* move backward first */
                }
            } else if (k) {
                @type@_upsampling_convolution_valid_sf(periodization_buf_rear, N_p,
                                                       filter, F, ptr_out, O,
                                                       MODE_ZEROPAD);
            }
        }
        if(periodization_buf_front != NULL) wtfree(periodization_buf_front);
        if(periodization_buf_rear != NULL) wtfree(periodization_buf_rear);

    }
    return 0;
}


/*
 * performs IDWT for all modes
 *
 * The upsampling is performed by splitting filters to even and odd elements
 * and performing 2 convolutions.  After refactoring the PERIODIZATION mode
 * case to separate function this looks much clearer now.
 */

int @type@_upsampling_convolution_valid_sf(const @type@ * const restrict input, const index_t N,
                                           const @type@ * const restrict filter, const index_t F,
                                           @type@ * const restrict output, const index_t O,
                                           MODE mode)
{
    if(mode == MODE_PERIODIZATION) /* Special case */
        return @type@_upsampling_convolution_valid_sf_periodization(input, N,
                                                                    filter, F,
                                                                    output, O);

    if((F%2) || (N < F/2)) /* Filter must have even length. */
        return -1;

    /* Perform _valid_ convolution (only when all filter_even and filter_odd elements
     * are in range of input data).
     *
     * This part is simple, no extra hacks, just two convolutions in one loop
     */
    for(index_t o = 0, i = F/2 - 1; i < N; ++i, o += 2){
        @type@ sum_even = 0;
        @type@ sum_odd = 0;

        for(index_t j = 0; j < F/2; ++j){
            sum_even += filter[j*2] * input[i-j];
            sum_odd += filter[j*2+1] * input[i-j];
        }
        output[o] += sum_even;
        output[o+1] += sum_odd;
    }
    return 0;
}

/* -> swt - todo */
int @type@_upsampled_filter_convolution(const @type@* input,
                                        const index_t N, const @type@*
                                        filter, const index_t F, @type@*
                                        output, const index_t step, MODE mode)
{
    return -1;
}

/**end repeat**/
